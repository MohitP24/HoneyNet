const express = require('express');
const router = express.Router();
const db = require('../database/connection');
const logger = require('../utils/logger');

/**
 * GET /api/malware
 * Get all malware analysis results with pagination
 */
router.get('/', async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = Math.min(parseInt(req.query.limit) || 50, 100);
    const offset = (page - 1) * limit;
    const onlyMalicious = req.query.malicious === 'true';

    const whereClause = onlyMalicious ? 'WHERE is_malicious = TRUE' : '';

    const query = `
      SELECT 
        id,
        file_name,
        file_size,
        sha256,
        md5,
        file_type,
        is_malicious,
        detection_ratio,
        analyzed_at,
        static_analysis->'indicators' as indicators,
        static_analysis->'entropy' as entropy,
        virustotal_data->'malicious' as vt_detections
      FROM malware_analysis
      ${whereClause}
      ORDER BY analyzed_at DESC
      LIMIT $1 OFFSET $2
    `;

    const countQuery = `SELECT COUNT(*) FROM malware_analysis ${whereClause}`;

    const [results, countResult] = await Promise.all([
      db.query(query, [limit, offset]),
      db.query(countQuery)
    ]);

    res.json({
      data: results.rows,
      pagination: {
        page,
        limit,
        total: parseInt(countResult.rows[0].count),
        totalPages: Math.ceil(countResult.rows[0].count / limit)
      }
    });
  } catch (error) {
    logger.error('Error fetching malware analysis:', error);
    res.status(500).json({ error: 'Failed to fetch malware analysis' });
  }
});

/**
 * GET /api/malware/:sha256
 * Get detailed analysis for specific file hash
 */
router.get('/:sha256', async (req, res) => {
  try {
    const { sha256 } = req.params;

    const query = `
      SELECT * FROM malware_analysis
      WHERE sha256 = $1
    `;

    const result = await db.query(query, [sha256]);

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'File not found' });
    }

    res.json(result.rows[0]);
  } catch (error) {
    logger.error('Error fetching malware details:', error);
    res.status(500).json({ error: 'Failed to fetch malware details' });
  }
});

/**
 * GET /api/malware/stats/summary
 * Get malware analysis statistics
 */
router.get('/stats/summary', async (req, res) => {
  try {
    const query = `
      SELECT 
        COUNT(*) as total_files,
        COUNT(*) FILTER (WHERE is_malicious = TRUE) as malicious_count,
        COUNT(*) FILTER (WHERE is_malicious = FALSE) as benign_count,
        COUNT(DISTINCT file_type) as unique_types,
        AVG(file_size) as avg_file_size,
        MAX(file_size) as max_file_size,
        MIN(analyzed_at) as first_analyzed,
        MAX(analyzed_at) as last_analyzed
      FROM malware_analysis
    `;

    const result = await db.query(query);
    res.json(result.rows[0]);
  } catch (error) {
    logger.error('Error fetching malware stats:', error);
    res.status(500).json({ error: 'Failed to fetch malware statistics' });
  }
});

/**
 * GET /api/malware/stats/file-types
 * Get distribution of file types
 */
router.get('/stats/file-types', async (req, res) => {
  try {
    const query = `
      SELECT 
        file_type,
        COUNT(*) as count,
        COUNT(*) FILTER (WHERE is_malicious = TRUE) as malicious_count,
        AVG(file_size) as avg_size
      FROM malware_analysis
      GROUP BY file_type
      ORDER BY count DESC
    `;

    const result = await db.query(query);
    res.json(result.rows);
  } catch (error) {
    logger.error('Error fetching file type stats:', error);
    res.status(500).json({ error: 'Failed to fetch file type statistics' });
  }
});

/**
 * GET /api/malware/stats/timeline
 * Get malware detection timeline
 */
router.get('/stats/timeline', async (req, res) => {
  try {
    const hours = parseInt(req.query.hours) || 24;

    const query = `
      SELECT 
        DATE_TRUNC('hour', analyzed_at) as hour,
        COUNT(*) as total,
        COUNT(*) FILTER (WHERE is_malicious = TRUE) as malicious
      FROM malware_analysis
      WHERE analyzed_at > NOW() - INTERVAL '${hours} hours'
      GROUP BY hour
      ORDER BY hour DESC
    `;

    const result = await db.query(query);
    res.json(result.rows);
  } catch (error) {
    logger.error('Error fetching malware timeline:', error);
    res.status(500).json({ error: 'Failed to fetch malware timeline' });
  }
});

/**
 * GET /api/malware/search
 * Search malware by various criteria
 */
router.get('/search', async (req, res) => {
  try {
    const { hash, filename, type } = req.query;
    const conditions = [];
    const params = [];

    if (hash) {
      params.push(`%${hash}%`);
      conditions.push(`(sha256 LIKE $${params.length} OR md5 LIKE $${params.length} OR sha1 LIKE $${params.length})`);
    }

    if (filename) {
      params.push(`%${filename}%`);
      conditions.push(`file_name ILIKE $${params.length}`);
    }

    if (type) {
      params.push(type);
      conditions.push(`file_type = $${params.length}`);
    }

    if (conditions.length === 0) {
      return res.status(400).json({ error: 'At least one search parameter required' });
    }

    const query = `
      SELECT 
        id,
        file_name,
        file_size,
        sha256,
        md5,
        file_type,
        is_malicious,
        detection_ratio,
        analyzed_at
      FROM malware_analysis
      WHERE ${conditions.join(' AND ')}
      ORDER BY analyzed_at DESC
      LIMIT 100
    `;

    const result = await db.query(query, params);
    res.json(result.rows);
  } catch (error) {
    logger.error('Error searching malware:', error);
    res.status(500).json({ error: 'Failed to search malware' });
  }
});

module.exports = router;
