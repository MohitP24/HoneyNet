const crypto = require('crypto');
const fs = require('fs').promises;
const path = require('path');
const axios = require('axios');
const logger = require('../utils/logger');
const db = require('../database/connection');

/**
 * Malware Analysis Service
 * Analyzes files downloaded/uploaded in honeypot
 * Integrates with VirusTotal API (optional) and local analysis
 */

class MalwareAnalysisService {
  constructor() {
    this.enabled = process.env.ENABLE_MALWARE_ANALYSIS !== 'false';
    this.virusTotalKey = process.env.VIRUSTOTAL_API_KEY;
    this.downloadPath = process.env.COWRIE_DOWNLOADS_PATH || '/home/cowrie/cowrie/var/lib/cowrie/downloads';
    this.analyzed = new Set(); // Track analyzed file hashes
    this.watchInterval = 60000; // Check for new files every minute
  }

  async analyzeFile(filePath, fileName) {
    try {
      if (!this.enabled) return null;

      logger.info(`Analyzing file: ${fileName}`);

      // Read file
      const fileBuffer = await fs.readFile(filePath);
      const fileHash = this.calculateHash(fileBuffer);

      // Check if already analyzed
      if (this.analyzed.has(fileHash)) {
        logger.debug(`File ${fileName} already analyzed (${fileHash})`);
        return null;
      }

      // Perform analysis
      const analysis = {
        file_name: fileName,
        file_path: filePath,
        file_size: fileBuffer.length,
        sha256: fileHash,
        md5: crypto.createHash('md5').update(fileBuffer).digest('hex'),
        sha1: crypto.createHash('sha1').update(fileBuffer).digest('hex'),
        analyzed_at: new Date()
      };

      // Basic static analysis
      const staticAnalysis = await this.performStaticAnalysis(fileBuffer, fileName);
      analysis.static_analysis = staticAnalysis;

      // VirusTotal check (if API key available)
      if (this.virusTotalKey) {
        const vtResult = await this.checkVirusTotal(fileHash);
        if (vtResult) {
          analysis.virustotal = vtResult;
          analysis.is_malicious = vtResult.malicious > 0;
          analysis.detection_ratio = `${vtResult.malicious}/${vtResult.total}`;
        }
      }

      // Store analysis
      await this.storeAnalysis(analysis);

      // Mark as analyzed
      this.analyzed.add(fileHash);

      logger.info(`File analysis complete: ${fileName}`, {
        hash: fileHash,
        is_malicious: analysis.is_malicious
      });

      return analysis;
    } catch (error) {
      logger.error(`File analysis failed for ${fileName}:`, error);
      return null;
    }
  }

  calculateHash(buffer) {
    return crypto.createHash('sha256').update(buffer).digest('hex');
  }

  async performStaticAnalysis(fileBuffer, fileName) {
    const analysis = {
      file_type: this.identifyFileType(fileBuffer, fileName),
      strings: [],
      suspicious_patterns: [],
      entropy: this.calculateEntropy(fileBuffer)
    };

    // Extract readable strings
    const strings = this.extractStrings(fileBuffer);
    analysis.strings = strings.slice(0, 100); // First 100 strings

    // Look for suspicious patterns
    const suspiciousPatterns = [
      { pattern: /eval\s*\(/gi, name: 'eval_function' },
      { pattern: /exec\s*\(/gi, name: 'exec_function' },
      { pattern: /system\s*\(/gi, name: 'system_function' },
      { pattern: /\/bin\/(bash|sh)/gi, name: 'shell_invocation' },
      { pattern: /wget|curl/gi, name: 'download_tool' },
      { pattern: /nc\s+-e|netcat/gi, name: 'reverse_shell' },
      { pattern: /base64|decode/gi, name: 'encoding' },
      { pattern: /\.exe|\.dll|\.so/gi, name: 'executable' },
      { pattern: /password|passwd|pwd/gi, name: 'credential_related' },
      { pattern: /http:\/\/|https:\/\//gi, name: 'url' },
      { pattern: /\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/g, name: 'ip_address' },
      { pattern: /crypt|encrypt|decrypt/gi, name: 'cryptography' }
    ];

    const fileString = fileBuffer.toString('utf8', 0, Math.min(fileBuffer.length, 10000));
    
    suspiciousPatterns.forEach(({ pattern, name }) => {
      const matches = fileString.match(pattern);
      if (matches && matches.length > 0) {
        analysis.suspicious_patterns.push({
          pattern: name,
          count: matches.length,
          samples: matches.slice(0, 5)
        });
      }
    });

    // Check for common malware indicators
    analysis.indicators = {
      has_shell_commands: /\/bin\/(bash|sh)/i.test(fileString),
      has_download_commands: /(wget|curl)/i.test(fileString),
      has_encoded_content: /base64|decode/i.test(fileString),
      has_network_activity: /\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/.test(fileString),
      high_entropy: analysis.entropy > 7.0 // Possibly packed/encrypted
    };

    return analysis;
  }

  identifyFileType(buffer, fileName) {
    // Magic number detection
    const magic = buffer.slice(0, 4).toString('hex');
    
    const magicNumbers = {
      '7f454c46': 'ELF executable',
      '4d5a9000': 'Windows PE executable',
      '504b0304': 'ZIP archive',
      '1f8b0800': 'GZIP compressed',
      '425a6839': 'BZIP2 compressed',
      '7573746172': 'TAR archive',
      '504b0506': 'JAR/APK file',
      '25504446': 'PDF document'
    };

    for (const [magic_sig, type] of Object.entries(magicNumbers)) {
      if (magic.startsWith(magic_sig)) {
        return type;
      }
    }

    // Fallback to extension
    const ext = path.extname(fileName).toLowerCase();
    const extensionMap = {
      '.sh': 'Shell script',
      '.py': 'Python script',
      '.pl': 'Perl script',
      '.php': 'PHP script',
      '.js': 'JavaScript',
      '.rb': 'Ruby script',
      '.exe': 'Windows executable',
      '.dll': 'Windows DLL',
      '.so': 'Linux shared library'
    };

    return extensionMap[ext] || 'Unknown';
  }

  extractStrings(buffer, minLength = 4) {
    const strings = [];
    let current = '';

    for (let i = 0; i < buffer.length; i++) {
      const byte = buffer[i];
      
      // Printable ASCII
      if (byte >= 32 && byte <= 126) {
        current += String.fromCharCode(byte);
      } else {
        if (current.length >= minLength) {
          strings.push(current);
        }
        current = '';
      }
    }

    if (current.length >= minLength) {
      strings.push(current);
    }

    return strings;
  }

  calculateEntropy(buffer) {
    const freq = new Array(256).fill(0);
    
    for (let i = 0; i < buffer.length; i++) {
      freq[buffer[i]]++;
    }

    let entropy = 0;
    for (let i = 0; i < 256; i++) {
      if (freq[i] > 0) {
        const p = freq[i] / buffer.length;
        entropy -= p * Math.log2(p);
      }
    }

    return entropy;
  }

  async checkVirusTotal(fileHash) {
    try {
      if (!this.virusTotalKey) {
        logger.debug('VirusTotal API key not configured, skipping online scan (using static analysis only)');
        return null;
      }

      logger.debug(`Checking VirusTotal for ${fileHash} (FREE tier: 500/day - no cost)`);

      const response = await axios.get(`https://www.virustotal.com/api/v3/files/${fileHash}`, {
        headers: {
          'x-apikey': this.virusTotalKey
        },
        timeout: 10000
      });

      const data = response.data.data.attributes;
      const stats = data.last_analysis_stats;

      return {
        malicious: stats.malicious || 0,
        suspicious: stats.suspicious || 0,
        undetected: stats.undetected || 0,
        harmless: stats.harmless || 0,
        total: Object.values(stats).reduce((a, b) => a + b, 0),
        scan_date: data.last_analysis_date,
        names: data.names || []
      };
    } catch (error) {
      if (error.response?.status === 404) {
        logger.debug(`File ${fileHash} not found in VirusTotal database`);
        return null;
      } else if (error.response?.status === 429) {
        logger.warn('VirusTotal rate limit exceeded (FREE tier: 500/day). Using static analysis only.');
        logger.info('No charges incurred. Limit resets at midnight UTC.');
      } else {
        logger.error('VirusTotal check failed:', error.message);
      }
      return null;
    }
  }

  async storeAnalysis(analysis) {
    try {
      const query = `
        INSERT INTO malware_analysis (
          id, file_name, file_path, file_size, sha256, md5, sha1,
          file_type, is_malicious, detection_ratio, 
          static_analysis, virustotal_data, analyzed_at
        ) VALUES (
          gen_random_uuid(), $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12
        )
        ON CONFLICT (sha256) DO UPDATE SET
          analyzed_at = EXCLUDED.analyzed_at,
          virustotal_data = EXCLUDED.virustotal_data
      `;

      const values = [
        analysis.file_name,
        analysis.file_path,
        analysis.file_size,
        analysis.sha256,
        analysis.md5,
        analysis.sha1,
        analysis.static_analysis?.file_type || 'Unknown',
        analysis.is_malicious || false,
        analysis.detection_ratio || null,
        JSON.stringify(analysis.static_analysis),
        JSON.stringify(analysis.virustotal || null),
        analysis.analyzed_at
      ];

      await db.query(query, values);
      logger.info('Malware analysis stored in database');
    } catch (error) {
      logger.error('Failed to store malware analysis:', error);
    }
  }

  async watchDownloadsDirectory() {
    if (!this.enabled) {
      logger.info('Malware analysis is disabled');
      return;
    }

    logger.info('Starting malware analysis watcher');

    // Check for new files periodically
    setInterval(async () => {
      await this.scanDirectory();
    }, this.watchInterval);

    // Initial scan
    await this.scanDirectory();
  }

  async scanDirectory() {
    try {
      const files = await fs.readdir(this.downloadPath);
      
      for (const fileName of files) {
        const filePath = path.join(this.downloadPath, fileName);
        const stats = await fs.stat(filePath);
        
        if (stats.isFile()) {
          await this.analyzeFile(filePath, fileName);
        }
      }
    } catch (error) {
      if (error.code === 'ENOENT') {
        logger.warn(`Downloads directory not found: ${this.downloadPath}`);
      } else {
        logger.error('Error scanning downloads directory:', error);
      }
    }
  }
}

module.exports = new MalwareAnalysisService();
